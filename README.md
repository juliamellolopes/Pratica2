<h1 align="center">Pratica N¬∫2-TRABALHO LISTA, PILHA, FILA</h1>
Neste trabalho teremos a implementa√ß√£o de quatro quest√µes de algoritmos utilizando as estruturas de Lista, Pilha e Fila. √â utilizado uma main.cpp para chamar uma classe Menu.hpp que de acordo com sua escolha alternativa ira chamar a fun√ß√£o correspondente na classe Funcoes.hpp, l√° se encontra as respectivas solu√ß√µes para cada quest√£o do trabalho utilizando as classes Lista, Fila e Pilha. Toda estrutura de programa√ß√£o se encontra na pasta src.
 
### Sum√°rio
<!--ts-->
   * [Copila√ß√£o](#Copila√ß√£o)
   * [Quest√£o1](#Quest√£o1)
   * [Quest√£o2](#Quest√£o2)
   * [Quest√£o3](#Quest√£o3)
   * [Quest√£o4](#Quest√£o4)
<!--te-->

### Copila√ß√£o

 Programa√ß√£o feita em C++, na plataforma DevC++, no Windows 10. Abra o arquivo Mikefile.cpp e copile:
	
    make
    make run
    
### Quest√£o1

Na Quest√£o 1 utilizaremos a implementa√ß√£o da estrutura Lista, arquivos referentes a sua estrutura se encontram na pasta src em Lista.cpp e Lista.hpp. Foram criadas fun√ß√µes para adicionar e retirar informa√ß√µes de dentro da lista, como pode ser visto a seguir:

	template <typename T> void List<T>::push(const T dado){
	  if (this->isEmpty()){
	    this->HEAD = new node<T>(dado);
	    this->TAIL = HEAD;
	    this->TAM++;
	  } else {
	    this->TAIL->prox = new node<T>(dado);
	    TAIL->prox->ant = TAIL;
	    TAIL = TAIL->prox;
	    TAIL->prox = NULL;
	    this->TAM++;
	  }
	}
	
	template <typename T> void List<T>::pop(){
	  if (!TAIL)
	    return;
	  node<T> *pNode = TAIL;
	  TAIL = TAIL->ant;
	  delete pNode;
	  pNode = NULL;
	  if (TAIL == NULL || HEAD == NULL){
	    HEAD = NULL;
	    TAIL = NULL;
	  }
	  this->TAM--;
	}
A resolu√ß√£o do problema 1a, 1b e 1c se encontram dentro da pasta src no arquivo Funcoes.cpp e Funcoes.hpp. Onde √© implementada cada quest√£o de forma eficaz nas fun√ß√µes: 

	void opcao1a();
	void opcao1b();
	void opcao1c();	

### Quest√£o2

Na Quest√£o 2 foi implementado heran√ßa para poder aproveitar a estrutura da Lista, dessa forma, somente foi necess√°rio fazer algumas mudan√ßas na fun√ß√£o Pop() em Fila.cpp. A classe Fila.hpp e Fila.cpp ficam com a estrutura para utiliza√ß√£o de uma fila. A baixo podemos ver como ficou a estrutura:

	template <typename T> void Fila<T>::pop(){
		if (!this->HEAD)
		    return;
	    	node<T> *pNode = this->HEAD;
	    	this->HEAD = this->HEAD->prox;
		delete pNode;
		pNode = NULL;
		this->TAM--;
	}
As resolu√ß√µes das quest√µes do problemas 2a, 2b e 2c se encontam na pasta src nos arquivos Funcoes.hpp e Funcoes.cpp. √â possivel encontrar as execu√ß√µes nas fun√ß√µes a baixo:

	void opcao2a();
	void opcao2b();
	void opcao2c();
	
### Quest√£o3
<h4 align> 
	Em constru√ß√£o...  üöß
</h4>

### Quest√£o4
<h4 align> 
	 Em constru√ß√£o...  üöß
</h4>
- [x] Cadastro de usu√°rio
- [x] Cadastro de cliente
- [x] Cadastro de produtos
>
